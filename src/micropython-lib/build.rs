//! Build script for embedding MicroPython runtime
//!
//! This script:
//! 1. Clones the MicroPython repository (if not already present)
//! 2. Checks out the specified version tag
//! 3. Runs the embed build to generate micropython_embed package
//! 4. Compiles the C sources for bare metal x86
//! 5. Generates Rust FFI bindings using bindgen

use std::env;
use std::path::{Path, PathBuf};
use std::process::Command;

/// MicroPython version to use
const MICROPYTHON_VERSION: &str = "v1.27.0";

/// MicroPython repository URL
const MICROPYTHON_REPO: &str = "https://github.com/micropython/micropython.git";

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set"));
    let manifest_dir =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set"));

    // Directory where we'll clone MicroPython
    let micropython_dir = out_dir.join("micropython");

    // Directory where the embed package will be generated
    let embed_dir = out_dir.join("micropython_embed");

    // Path to our stubs
    let stubs_dir = manifest_dir.join("stubs");
    let stubs_include_dir = stubs_dir.join("include");

    println!("cargo:rerun-if-changed=stubs/include/mpconfigport.h");
    println!("cargo:rerun-if-changed=stubs/micropython_stubs.c");
    println!("cargo:rerun-if-changed=stubs/include/wrapper.h");
    println!("cargo:rerun-if-changed=Cargo.toml");
    println!("cargo:rerun-if-changed=build.rs");

    // Clone MicroPython repository if not present
    clone_micropython(&micropython_dir);

    // Checkout the correct version
    checkout_version(&micropython_dir, MICROPYTHON_VERSION);

    // Build the embed package
    build_embed_package(&micropython_dir, &embed_dir, &stubs_include_dir);

    println!(
        "cargo:warning=MicroPython embed package built successfully at {:?}",
        embed_dir
    );

    // Compile C sources for bare metal x86
    compile_micropython(&embed_dir, &stubs_dir, &stubs_include_dir);

    println!("cargo:warning=MicroPython compiled successfully!");

    // Generate Rust FFI bindings
    generate_bindings(&embed_dir, &stubs_include_dir, &out_dir);

    println!("cargo:warning=Bindings generated successfully!");
}

/// Clone the MicroPython repository if it doesn't exist
fn clone_micropython(target_dir: &Path) {
    if target_dir.join(".git").exists() {
        println!(
            "cargo:warning=MicroPython repository already exists at {:?}",
            target_dir
        );
        return;
    }

    println!("cargo:warning=Cloning MicroPython repository...");

    let status = Command::new("git")
        .args([
            "clone",
            "--depth",
            "1",
            "--branch",
            MICROPYTHON_VERSION,
            MICROPYTHON_REPO,
        ])
        .arg(target_dir)
        .status()
        .expect("Failed to execute git clone");

    if !status.success() {
        // If shallow clone with tag fails, do a full clone
        println!("cargo:warning=Shallow clone failed, trying full clone...");

        let status = Command::new("git")
            .args(["clone", MICROPYTHON_REPO])
            .arg(target_dir)
            .status()
            .expect("Failed to execute git clone");

        if !status.success() {
            panic!("Failed to clone MicroPython repository");
        }
    }
}

/// Checkout the specified version tag
fn checkout_version(repo_dir: &Path, version: &str) {
    println!("cargo:warning=Checking out MicroPython {}...", version);

    // Fetch tags if needed
    let _ = Command::new("git")
        .args(["fetch", "--tags"])
        .current_dir(repo_dir)
        .status();

    let status = Command::new("git")
        .args(["checkout", version])
        .current_dir(repo_dir)
        .status()
        .expect("Failed to execute git checkout");

    if !status.success() {
        panic!("Failed to checkout MicroPython version {}", version);
    }
}

/// Build the MicroPython embed package
fn build_embed_package(micropython_dir: &Path, embed_dir: &Path, config_include_dir: &Path) {
    println!("cargo:warning=Building MicroPython embed package...");

    // First, let's create a build directory
    let build_dir = embed_dir.parent().unwrap().join("micropython_build");
    std::fs::create_dir_all(&build_dir).expect("Failed to create build directory");

    // Copy our mpconfigport.h to the build directory
    let config_src = config_include_dir.join("mpconfigport.h");
    let config_dst = build_dir.join("mpconfigport.h");
    std::fs::copy(&config_src, &config_dst).expect("Failed to copy mpconfigport.h");

    // Create a custom micropython_embed.mk in the build directory
    let embed_mk_content = format!(
        r#"# Auto-generated by build.rs
MICROPYTHON_TOP = {micropython_top}
PACKAGE_DIR = {package_dir}
include $(MICROPYTHON_TOP)/ports/embed/embed.mk
"#,
        micropython_top = micropython_dir.display(),
        package_dir = embed_dir.display(),
    );

    let embed_mk_path = build_dir.join("micropython_embed.mk");
    std::fs::write(&embed_mk_path, embed_mk_content).expect("Failed to write micropython_embed.mk");

    // Run make to build the embed package
    let status = Command::new("make")
        .args(["-f", "micropython_embed.mk"])
        .current_dir(&build_dir)
        .env("CFLAGS", format!("-I{}", config_include_dir.display()))
        .status()
        .expect("Failed to execute make");

    if !status.success() {
        panic!("Failed to build MicroPython embed package");
    }

    // Verify the embed package was created
    if !embed_dir.exists() {
        panic!(
            "MicroPython embed package was not created at {:?}",
            embed_dir
        );
    }

    println!(
        "cargo:warning=MicroPython embed package created at {:?}",
        embed_dir
    );
}

/// Compile MicroPython C sources for bare metal x86
fn compile_micropython(embed_dir: &Path, stubs_dir: &Path, stubs_include_dir: &Path) {
    println!("cargo:warning=Compiling MicroPython C sources...");

    let mut build = cc::Build::new();

    // Use gnu99 instead of c99 to support GNU extensions (inline asm, etc.)
    build.std("gnu99").flag("-fPIC").flag("-Wno-sign-compare");

    // Include paths
    // Our mpconfigport.h
    // Port-specific headers
    build.include(stubs_include_dir);
    build.include(embed_dir);
    build.include(embed_dir.join("port"));
    build.include(embed_dir.join("py"));
    build.include(embed_dir.join("exmod"));
    build.include(embed_dir.join("shared"));
    build.include(embed_dir.join("genhdr"));

    // Collect all C source files from the embed package
    let mut c_files: Vec<PathBuf> = Vec::new();

    // py/*.c - Core Python VM
    collect_c_files(&embed_dir.join("py"), &mut c_files);

    let dirs = ["extmod", "genhdr", "port", "py", "shared"];

    for dir in dirs {
        let path = embed_dir.join(dir);
        if path.exists() {
            collect_c_files_recursive(&path, &mut c_files);
        }
    }

    println!(
        "cargo:warning=Found {} MicroPython C files to compile",
        c_files.len()
    );

    // Add all MicroPython source files
    for c_file in &c_files {
        build.file(c_file);
    }

    // Add our stubs
    let stubs_file = stubs_dir.join("micropython_stubs.c");
    if stubs_file.exists() {
        build.file(&stubs_file);
        println!("cargo:warning=Including stubs file: {:?}", stubs_file);
    }

    // Compile to static library
    build.compile("micropython");

    println!("cargo:warning=MicroPython library compiled successfully");
}

/// Collect all .c files in a directory (non-recursive)
fn collect_c_files(dir: &Path, files: &mut Vec<PathBuf>) {
    if let Ok(entries) = std::fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.extension().map_or(false, |e| e == "c") {
                files.push(path);
            }
        }
    }
}

/// Collect all .c files in a directory (recursive)
fn collect_c_files_recursive(dir: &Path, files: &mut Vec<PathBuf>) {
    if let Ok(entries) = std::fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                collect_c_files_recursive(&path, files);
            } else if path.extension().map_or(false, |e| e == "c") {
                files.push(path);
            }
        }
    }
}

/// Generate Rust FFI bindings using bindgen
fn generate_bindings(embed_dir: &Path, stubs_include_dir: &Path, out_dir: &Path) {
    println!("cargo:warning=Generating Rust FFI bindings...");

    // Create a wrapper header that includes the MicroPython embed API
    let wrapper_h = stubs_include_dir.join("wrapper.h");

    // If wrapper.h doesn't exist, create it
    if !wrapper_h.exists() {
        let wrapper_content = r#"/*
 * Wrapper header for bindgen to generate Rust FFI bindings
 * for the MicroPython embed API.
 */

#include "port/micropython_embed.h"
"#;
        std::fs::write(&wrapper_h, wrapper_content).expect("Failed to write wrapper.h");
    }

    let bindings = bindgen::Builder::default()
        // The input header file
        .header(wrapper_h.to_str().unwrap())
        // Include paths
        .clang_arg(format!("-I{}", stubs_include_dir.display()))
        .clang_arg(format!("-I{}", embed_dir.display()))
        .clang_arg(format!("-I{}", embed_dir.join("port").display()))
        // Use core instead of std
        .use_core()
        // Don't generate layout tests (they require std)
        .layout_tests(false)
        // Derive common traits
        .derive_default(true)
        .derive_debug(true)
        // Allowlist only the functions we need from the embed API
        .allowlist_function("mp_embed_init")
        .allowlist_function("mp_embed_deinit")
        .allowlist_function("mp_embed_exec_str")
        // Also allow some useful types
        .allowlist_type("mp_obj_t")
        .allowlist_type("mp_state_ctx_t")
        // Generate bindings
        .generate()
        .expect("Unable to generate bindings");

    // Write the bindings to the output directory
    let bindings_path = out_dir.join("bindings.rs");
    bindings
        .write_to_file(&bindings_path)
        .expect("Couldn't write bindings!");

    println!("cargo:warning=Bindings written to {:?}", bindings_path);
}
